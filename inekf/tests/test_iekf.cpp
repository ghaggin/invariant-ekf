#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_MODULE test_iekf
#include <boost/test/unit_test.hpp>

#include <IEKF.hpp>
#include <utils.hpp>

#include <eigen3/Eigen/Dense>

#include <iostream>
#include <tuple>

using namespace Eigen;
using namespace iekf;
using namespace std::chrono;

using Matrix5d = IEKF::Matrix5d;
using Matrix15d = IEKF::Matrix15d;
using Timestamp = IEKF::Timestamp;
using Seconds = IEKF::Seconds;

const double tol = 1e-5;

Timestamp Ts(const double t)
{
    return Timestamp{Seconds{t}};
}

/*****************************************************************************/
// return absolute value of the max difference of any single element in two
// matrices
template <typename EigenMatd>
static double max_diff(const EigenMatd& m1, const EigenMatd& m2)
{
    return (m1 - m2).cwiseAbs().maxCoeff();
}

/*****************************************************************************/
// Defind some shorthand identity matrices
const Matrix3d Id3 = Matrix3d::Identity();
const Matrix5d Id5 = Matrix5d::Identity();
const Matrix15d Id15 = Matrix15d::Identity();

/*****************************************************************************/
BOOST_AUTO_TEST_CASE(default_constructor)
{
    IEKF iekf;
    Matrix5d mu;
    Matrix15d Sigma;
    Timestamp time;
    std::tie(mu, Sigma, time) = iekf.getState();

    auto a = (mu - Matrix5d::Identity()).cwiseAbs().maxCoeff();
    BOOST_CHECK_CLOSE(a, 0, tol);

    a = (Sigma - Matrix15d::Identity()).cwiseAbs().maxCoeff();
    BOOST_CHECK_CLOSE(a, 0, tol);
}

/*****************************************************************************/
BOOST_AUTO_TEST_CASE(constructor)
{
    auto mu_in = arange_square<double, 5>();
    auto Sigma_in = arange_square<double, 15>();

    IEKF iekf(mu_in, Sigma_in);

    Matrix5d mu_out;
    Matrix15d Sigma_out;
    Timestamp time_out;
    std::tie(mu_out, Sigma_out, time_out) = iekf.getState();

    auto a = (mu_out - arange_square<double, 5>()).cwiseAbs().maxCoeff();
    BOOST_CHECK_CLOSE(a, 0, tol);

    a = (Sigma_out - arange_square<double, 15>()).cwiseAbs().maxCoeff();
    BOOST_CHECK_CLOSE(a, 0, tol);
}

/*****************************************************************************/
BOOST_AUTO_TEST_CASE(interfaces)
{
    auto mu = arange_square<double, 5>();
    auto Sigma = Matrix15d::Identity();
    IEKF iekf(mu, Sigma);
    auto R = iekf.R();
    auto p = iekf.p();
    auto v = iekf.v();

    auto R_sol = (Matrix3d() << 0, 1, 2, 5, 6, 7, 10, 11, 12).finished();
    auto p_sol = (Vector3d() << 4, 9, 14).finished();
    auto v_sol = (Vector3d() << 3, 8, 13).finished();

    auto a = (R - R_sol).cwiseAbs().maxCoeff();
    BOOST_CHECK_CLOSE(a, 0, tol);

    a = (p - p_sol).cwiseAbs().maxCoeff();
    BOOST_CHECK_CLOSE(a, 0, tol);

    a = (v - v_sol).cwiseAbs().maxCoeff();
    BOOST_CHECK_CLOSE(a, 0, tol);
}

/*****************************************************************************/
// Run a test with zero inputs for accel and gyro, should return
// the starting state
BOOST_AUTO_TEST_CASE(prediction_zero_meas)
{
    // Default construct with mu = Id
    IEKF iekf{};

    auto acc = Vector3d::Zero();
    auto gyro = Vector3d::Zero();
    Timestamp time{Seconds{0}};

    // Add imu measurement
    iekf.addImu(time, acc, gyro);

    auto mu = iekf.mu();

    auto a = max_diff(mu, Id5);
    BOOST_CHECK_CLOSE(a, 0, tol);
}

/*****************************************************************************/
// Test with constant gyroscope measurements and accel just measureing gravity
BOOST_AUTO_TEST_CASE(prediction_const_gyro)
{
    // Default construct with mu = Id
    IEKF iekf;

    auto g = iekf.g();

    auto acc = (Vector3d() << 0.0, 0.0, g).finished();
    auto gyro = (Vector3d() << 2 * M_PI, 0, 0).finished();

    Timestamp time{Seconds{1}};

    iekf.addImu(time, acc, gyro);

    auto R = iekf.R();
    auto R_sol = Id3;

    auto a = max_diff(R, R_sol);
    BOOST_CHECK(a < 1e-8);
}

/*****************************************************************************/
// Test with constant accel but no gyro input.  Body aligned with world frame
// should simulate pure rectilinear motion
BOOST_AUTO_TEST_CASE(prediction_const_acc)
{
    // Default construct with mu = Id
    IEKF iekf;

    auto g = iekf.g();

    // Measure 1 m/s^2 accel in body frame x
    // keep body frame aligned with world frame, look for accel in x
    auto acc = (Vector3d() << 1.0, 0.0, g).finished();
    auto gyro = Vector3d::Zero();

    // Default constructor sets time to zero
    // Set first imu measurement at 1 seconds
    Timestamp time{Seconds{1}};

    // Add imu measurement
    // Accelerate 1 m/s^2 in x for 1 sec
    iekf.addImu(time, acc, gyro);

    // Extract state
    auto R = iekf.R();
    auto p = iekf.p();
    auto v = iekf.v();

    // Set solution
    //  R - vehicle should not have rotated -> identity
    //  p - should move 1/2*a*t^2, since t = 1 and a = 1, p = 1/2
    //  v - should change to a*t, since a = 1 and t = 1, v = 1
    auto R_sol = Id3;
    auto p_sol = (Vector3d{} << 0.5, 0, 0).finished();
    auto v_sol = (Vector3d{} << 1., 0, 0).finished();

    // Check the state vs solution
    auto a = max_diff(R, R_sol);
    BOOST_CHECK(a < 1e-8);

    a = max_diff(p, p_sol);
    BOOST_CHECK(a < 1e-8);

    a = max_diff(v, v_sol);
    BOOST_CHECK(a < 1e-8);

    // Now accelerate in y for 1 sec
    // note that velocity in x is now 1
    acc = (Vector3d{} << 0, 1, g).finished();
    time = Timestamp{Seconds{2}};
    iekf.addImu(time, acc, gyro);
    R = iekf.R();
    p = iekf.p();
    v = iekf.v();
    p_sol = (Vector3d{} << 1.5, 0.5, 0).finished();
    v_sol = (Vector3d{} << 1., 1., 0).finished();
    BOOST_CHECK(max_diff(R, R_sol) < 1e-8);
    BOOST_CHECK(max_diff(p, p_sol) < 1e-8);
    BOOST_CHECK(max_diff(v, v_sol) < 1e-8);

    // Now accelerate in z for 1 sec
    // note that x and y velocty are now 1
    acc = (Vector3d{} << 0, 0, g + 1).finished();
    time = Timestamp{Seconds{3}};
    iekf.addImu(time, acc, gyro);
    R = iekf.R();
    p = iekf.p();
    v = iekf.v();
    p_sol = (Vector3d{} << 2.5, 1.5, 0.5).finished();
    v_sol = (Vector3d{} << 1., 1., 1.).finished();
    BOOST_CHECK(max_diff(R, R_sol) < 1e-8);
    BOOST_CHECK(max_diff(p, p_sol) < 1e-8);
    BOOST_CHECK(max_diff(v, v_sol) < 1e-8);
}

/*****************************************************************************/
// Test with constant accel and gyro over 1 sec
// Correct output determined from the prediction function
// in scripts/LIEKF.m with default initial conditions and
//  w = [0.3, 0.5, 0.7]
//  a = [0.11, 0.13, 0.17]
//  dt = 0.19
BOOST_AUTO_TEST_CASE(test_accel_and_gyro)
{
    // Solution determined from scripts/LIEKF.m
    Matrix5d mu_sol =
        (Matrix5d{} << 0.986676318023551, -0.129636068151535, 0.098307340955289,
            0.020762064018513, 0.001977230017723, 0.135037560844690,
            0.989557114126567, -0.050414036166701, 0.025168814239892,
            0.002376210384301, -0.090745251184872, 0.063017519117396,
            0.993878308281091, -1.831875751893571, -0.174019677424953, 0, 0, 0,
            1.000000000000000, 0, 0, 0, 0, 0, 1.000000000000000)
            .finished();

    Matrix15d Sigma_sol;
    Sigma_sol << 1.232863461571023, 0.000019365897766, 0.000027112256872,
        -0.000023730555728, -0.039483575523859, 0.029369185224596,
        -0.000002253540408, -0.003740548381674, 0.002755741530718,
        -0.225094834504368, -0.015201894473955, 0.010427710840411, 0, 0, 0,
        0.000019365897766, 1.232884118528640, 0.000045187094786,
        0.039495701373406, -0.000019604557833, -0.025401580635577,
        0.003741697537687, -0.000001869494669, -0.002401331442236,
        0.014794394948699, -0.225312167584505, -0.006903192417654, 0, 0, 0,
        0.000027112256872, 0.000045187094786, 1.232915103965065,
        -0.029352673816777, 0.025424279691831, -0.000012640925080,
        -0.002754168277903, 0.002403482394299, -0.000001194688594,
        -0.010998210175770, 0.005952360192056, -0.225638167204709, 0, 0, 0,
        -0.000023730555728, 0.039495701373406, -0.029352673816777,
        1.234844664943277, -0.000591056016576, -0.000794026984087,
        0.230359632717780, -0.000146333087748, -0.000010779962094,
        0.000499078611702, -0.003750338520980, 0.002597732730292,
        -0.225094834504368, -0.015201894473955, 0.010427710840411,
        -0.039483575523859, -0.000019604557833, 0.025424279691831,
        -0.000591056016576, 1.234688565679871, -0.000903399602389,
        0.000034692271192, 0.230345334426058, -0.000123680252335,
        0.003495291397473, 0.000412315643996, -0.002587148840871,
        0.014794394948699, -0.225312167584505, -0.006903192417654,
        0.029369185224596, -0.025401580635577, -0.000012640925080,
        -0.000794026984087, -0.000903399602389, 1.234148677249681,
        -0.000139944009303, -0.000047132634646, 0.230293395213295,
        -0.002945018714595, 0.002109760971096, 0.000265871211426,
        -0.010998210175770, 0.005952360192056, -0.225638167204709,
        -0.000002253540408, 0.003741697537687, -0.002754168277903,
        0.230359632717780, 0.000034692271192, -0.000139944009303,
        1.233363912533817, -0.000005335343524, -0.000007241487867,
        0.000035538363179, -0.000238668574562, 0.000162027355185,
        -0.021336287770318, -0.001927844775571, 0.001315655312687,
        -0.003740548381674, -0.000001869494669, 0.002403482394299,
        -0.000146333087748, 0.230345334426058, -0.000047132634646,
        -0.000005335343524, 1.233362540425678, -0.000008218322690,
        0.000220525561452, 0.000029431458315, -0.000165724014486,
        0.001869785763538, -0.021367252576736, -0.000881513486705,
        0.002755741530718, -0.002401331442236, -0.000001194688594,
        -0.000010779962094, -0.000123680252335, 0.230293395213295,
        -0.000007241487867, -0.000008218322690, 1.233357446788699,
        -0.000186807955128, 0.000131771715041, 0.000018882378562,
        -0.001396937929533, 0.000746042458627, -0.021413699786363,
        -0.225094834504368, 0.014794394948699, -0.010998210175770,
        0.000499078611702, 0.003495291397473, -0.002945018714595,
        0.000035538363179, 0.000220525561452, -0.000186807955128,
        1.190000000000000, 0, 0, 0, 0, 0, -0.015201894473955,
        -0.225312167584505, 0.005952360192056, -0.003750338520980,
        0.000412315643996, 0.002109760971096, -0.000238668574562,
        0.000029431458315, 0.000131771715041, 0, 1.190000000000000, 0, 0, 0, 0,
        0.010427710840411, -0.006903192417654, -0.225638167204709,
        0.002597732730292, -0.002587148840871, 0.000265871211426,
        0.000162027355185, -0.000165724014486, 0.000018882378562, 0, 0,
        1.190000000000000, 0, 0, 0, 0, 0, 0, -0.225094834504368,
        0.014794394948699, -0.010998210175770, -0.021336287770318,
        0.001869785763538, -0.001396937929533, 0, 0, 0, 1.190000000000000, 0, 0,
        0, 0, 0, -0.015201894473955, -0.225312167584505, 0.005952360192056,
        -0.001927844775571, -0.021367252576736, 0.000746042458627, 0, 0, 0, 0,
        1.190000000000000, 0, 0, 0, 0, 0.010427710840411, -0.006903192417654,
        -0.225638167204709, 0.001315655312687, -0.000881513486705,
        -0.021413699786363, 0, 0, 0, 0, 0, 1.190000000000000;

    Vector3d w{0.3, 0.5, 0.7};
    Vector3d a{0.11, 0.13, 0.17};
    Timestamp time{Seconds{0.19}};

    IEKF iekf{};

    iekf.addImu(time, a, w);

    Matrix15d Sigma = iekf.Sigma();

    BOOST_CHECK(max_diff(iekf.mu(), mu_sol) < 1e-8);
    BOOST_CHECK(max_diff(Sigma, Sigma_sol) < 1e-8);
}

/*****************************************************************************/
// Simple test, zero update should keep filter at origin
BOOST_AUTO_TEST_CASE(test_correct)
{
    IEKF iekf{};
    Vector3d gps{0, 0, 0};       // equator, prime mer, msl
    Timestamp time{Seconds{0}};  // doesnt matter for gps meas

    iekf.addGps(time, gps);

    BOOST_CHECK(max_diff(iekf.mu(), Id5) < 1e-8);
}

/*****************************************************************************/
// Now give the filter a nonzero update, solution generated from matlab version
// of the filter
BOOST_AUTO_TEST_CASE(test_update2)
{
    Matrix5d mu_sol;
    mu_sol <<

        1.000000000000000,
        0, 0, 0, 46.582816544073772, 0, 1.000000000000000, 0, 0,
        2.286512218177096, 0, 0, 1.000000000000000, 0, -0.991163688521989, 0, 0,
        0, 1.000000000000000, 0, 0, 0, 0, 0, 1.000000000000000;

    IEKF iekf{};
    Vector3d gps{1, 2, 3};
    Timestamp time{Seconds{0}};  // doesnt matter for gps meas

    // Set filter origin
    // without this origin is set to first update measurement
    iekf.resetFilter(time, Vector3d::Zero());

    iekf.addGps(time, gps);

    BOOST_CHECK(max_diff(iekf.mu(), mu_sol) < 1e-3);  // big numbers
}

/*****************************************************************************/
// two sequential predictions
BOOST_AUTO_TEST_CASE(test_two_predictions)
{
    IEKF iekf{};
    Vector3d w{0.3, 0.5, 0.7};
    Vector3d a{0.11, 0.13, 0.17};
    iekf.addImu(Ts(0.19), a, w);

    iekf.addImu(Ts(0.27), a, w);

    Matrix5d mu_sol;
    mu_sol << 0.973162730597739, -0.181659800386756, 0.141258687162937,
        0.029396711070180, 0.003984086586539, 0.192539774468753,
        0.978965383441471, -0.067492320087659, 0.036044893440882,
        0.004823667922829, -0.126026723448141, 0.092878926278987,
        0.987669362707069, -2.603344942916421, -0.351427942767680, 0, 0, 0,
        1.000000000000000, 0, 0, 0, 0, 0, 1.000000000000000;

    BOOST_CHECK(max_diff(iekf.mu(), mu_sol) < 1e-3);
}

/*****************************************************************************/
// run correction step then prediction
BOOST_AUTO_TEST_CASE(test_correct_then_predict)
{
    IEKF iekf{};

    Vector3d w{0.3, 0.5, 0.7};
    Vector3d a{0.11, 0.13, 0.17};
    Vector3d gps{0, 0, 0};

    iekf.addGps(Ts(0.03), gps);

    iekf.addImu(Ts(0.19), a, w);

    Matrix5d mu_sol;
    mu_sol << 0.986676318023551, -0.129636068151535, 0.098307340955289,
        0.020762064018513, 0.001977230017723, 0.135037560844690,
        0.989557114126567, -0.050414036166701, 0.025168814239892,
        0.002376210384301, -0.090745251184872, 0.063017519117396,
        0.993878308281091, -1.831875751893571, -0.174019677424953, 0, 0, 0,
        1.000000000000000, 0, 0, 0, 0, 0, 1.000000000000000;

    Matrix15d Sigma_sol;
    Sigma_sol << 1.232863461571023, 0.000019365897766, 0.000027112256872,
        -0.000023730555728, -0.039483575523859, 0.029369185224596,
        -0.000002253540408, -0.003740548381674, 0.002755741530718,
        -0.225094834504368, -0.015201894473955, 0.010427710840411, 0, 0, 0,
        0.000019365897766, 1.232884118528640, 0.000045187094786,
        0.039495701373406, -0.000019604557833, -0.025401580635577,
        0.003741697537687, -0.000001869494669, -0.002401331442236,
        0.014794394948699, -0.225312167584505, -0.006903192417654, 0, 0, 0,
        0.000027112256872, 0.000045187094786, 1.232915103965065,
        -0.029352673816777, 0.025424279691831, -0.000012640925080,
        -0.002754168277903, 0.002403482394299, -0.000001194688594,
        -0.010998210175770, 0.005952360192056, -0.225638167204709, 0, 0, 0,
        -0.000023730555728, 0.039495701373406, -0.029352673816777,
        1.234844664943277, -0.000591056016576, -0.000794026984087,
        0.230359632717780, -0.000146333087748, -0.000010779962094,
        0.000499078611702, -0.003750338520980, 0.002597732730292,
        -0.225094834504368, -0.015201894473955, 0.010427710840411,
        -0.039483575523859, -0.000019604557833, 0.025424279691831,
        -0.000591056016576, 1.234688565679871, -0.000903399602389,
        0.000034692271192, 0.230345334426058, -0.000123680252335,
        0.003495291397473, 0.000412315643996, -0.002587148840871,
        0.014794394948699, -0.225312167584505, -0.006903192417654,
        0.029369185224596, -0.025401580635577, -0.000012640925080,
        -0.000794026984087, -0.000903399602389, 1.234148677249681,
        -0.000139944009303, -0.000047132634646, 0.230293395213295,
        -0.002945018714595, 0.002109760971096, 0.000265871211426,
        -0.010998210175770, 0.005952360192056, -0.225638167204709,
        -0.000002253540408, 0.003741697537687, -0.002754168277903,
        0.230359632717780, 0.000034692271192, -0.000139944009303,
        1.233148734756877, 0.000049690313303, -0.000032445182520,
        0.000035538363179, -0.000238668574562, 0.000162027355185,
        -0.021336287770318, -0.001927844775571, 0.001315655312687,
        -0.003740548381674, -0.000001869494669, 0.002403482394299,
        -0.000146333087748, 0.230345334426058, -0.000047132634646,
        0.000049690313303, 1.233244848242687, 0.000030280795142,
        0.000220525561452, 0.000029431458315, -0.000165724014486,
        0.001869785763538, -0.021367252576736, -0.000881513486705,
        0.002755741530718, -0.002401331442236, -0.000001194688594,
        -0.000010779962094, -0.000123680252335, 0.230293395213295,
        -0.000032445182520, 0.000030280795142, 1.233298323615716,
        -0.000186807955128, 0.000131771715041, 0.000018882378562,
        -0.001396937929533, 0.000746042458627, -0.021413699786363,
        -0.225094834504368, 0.014794394948699, -0.010998210175770,
        0.000499078611702, 0.003495291397473, -0.002945018714595,
        0.000035538363179, 0.000220525561452, -0.000186807955128,
        1.190000000000000, 0, 0, 0, 0, 0, -0.015201894473955,
        -0.225312167584505, 0.005952360192056, -0.003750338520980,
        0.000412315643996, 0.002109760971096, -0.000238668574562,
        0.000029431458315, 0.000131771715041, 0, 1.190000000000000, 0, 0, 0, 0,
        0.010427710840411, -0.006903192417654, -0.225638167204709,
        0.002597732730292, -0.002587148840871, 0.000265871211426,
        0.000162027355185, -0.000165724014486, 0.000018882378562, 0, 0,
        1.190000000000000, 0, 0, 0, 0, 0, 0, -0.225094834504368,
        0.014794394948699, -0.010998210175770, -0.021336287770318,
        0.001869785763538, -0.001396937929533, 0, 0, 0, 1.190000000000000, 0, 0,
        0, 0, 0, -0.015201894473955, -0.225312167584505, 0.005952360192056,
        -0.001927844775571, -0.021367252576736, 0.000746042458627, 0, 0, 0, 0,
        1.190000000000000, 0, 0, 0, 0, 0.010427710840411, -0.006903192417654,
        -0.225638167204709, 0.001315655312687, -0.000881513486705,
        -0.021413699786363, 0, 0, 0, 0, 0, 1.190000000000000;

    BOOST_CHECK(max_diff(iekf.mu(), mu_sol) < 1e-3);
    BOOST_CHECK(max_diff(iekf.Sigma(), Sigma_sol) < 1e-3);
}

/*****************************************************************************/
// predict then correct
BOOST_AUTO_TEST_CASE(test_predict_correct1)
{
    IEKF iekf{};
    Vector3d w{0.3, 0.5, 0.7};
    Vector3d a{0.11, 0.13, 0.17};
    Vector3d gps{0, 0, 0};

    iekf.addImu(Ts(0.19), a, w);

    iekf.addGps(Ts(0.27), gps);

    Matrix5d mu = iekf.mu();
    Matrix5d mu_sol;
    mu_sol << 0.986676321687830, -0.129636052987657, 0.098307324174527,
        0.020762411943673, 0.001979089217068, 0.135037548756192,
        0.989557113440060, -0.050414082021740, 0.025167650670030,
        0.002369985767943, -0.090745229331866, 0.063017561091787,
        0.993878307614946, -1.831873661400391, -0.174008481979867, 0, 0, 0,
        1.000000000000000, 0, 0, 0, 0, 0, 1.000000000000000;

    BOOST_CHECK(max_diff(mu, mu_sol) < 1e-3);
}

// /*****************************************************************************/
// // predict x2 then correct
BOOST_AUTO_TEST_CASE(test_predict_correct2)
{
    IEKF iekf{};
    iekf.resetFilter(Ts(0), Vector3d{0, 0, 0});

    Vector3d w{0.3, 0.5, 0.7};
    Vector3d a{0.11, 0.13, 0.17};
    Vector3d gps = Vector3d::Zero();

    iekf.addImu(Ts(0.19), a, w);

    iekf.addImu(Ts(0.27), a, w);

    iekf.addGps(Ts(0.53), gps);

    Matrix5d mu = iekf.mu();
    Matrix5d mu_sol;  // solution from matlab
    mu_sol << 0.973162752045982, -0.181659739990569, 0.141258617071133,
        0.029397753408070, 0.003988227249344, 0.192539731653536,
        0.978965378586072, -0.067492512655945, 0.036041421927547,
        0.004809813542175, -0.126026623239197, 0.092879095583383,
        0.987669359572594, -2.603338715095498, -0.351403031683255, 0, 0, 0,
        1.000000000000000, 0, 0, 0, 0, 0, 1.000000000000000;

    BOOST_CHECK(max_diff(mu, mu_sol) < 1e-3);
}

/*****************************************************************************/
BOOST_AUTO_TEST_CASE(test_predict_correct4)
{
    IEKF iekf{};
    Vector3d w{0.3, 0.5, 0.7};
    Vector3d a{0.11, 0.13, 0.17};
    Vector3d gps = Vector3d::Zero();

    iekf.addImu(Ts(0.19), a, w);

    iekf.addImu(Ts(0.27), a, w);

    iekf.addImu(Ts(0.57), a, w);

    iekf.addGps(Ts(0.83), gps);

    Matrix5d mu = iekf.mu();
    Matrix5d mu_sol;  // solution from matlab
    mu_sol << 0.882465298495445, -0.357481446703058, 0.305715574046259,
        0.060962402943868, 0.017600233539659, 0.405131818201197,
        0.907877037317295, -0.107830862896313, 0.078205819935994,
        0.021820534664340, -0.239004616759461, 0.219012100978600,
        0.945997089209371, -5.496937585778022, -1.566292369714525, 0, 0, 0,
        1.000000000000000, 0, 0, 0, 0, 0, 1.000000000000000;

    BOOST_CHECK(max_diff(mu, mu_sol) < 1e-3);
}

/*****************************************************************************/
BOOST_AUTO_TEST_CASE(test_predict_correct5)
{
    IEKF iekf{};
    Vector3d w{0.3, 0.5, 0.7};
    Vector3d a{0.11, 0.13, 0.17};
    Vector3d gps = Vector3d::Zero();

    iekf.addImu(Ts(0.19), a, w);

    iekf.addImu(Ts(0.27), a, w);

    iekf.addGps(Ts(0.29), gps);

    iekf.addImu(Ts(0.57), a, w);

    iekf.addGps(Ts(0.89), gps);

    Matrix5d mu = iekf.mu();
    Matrix5d mu_sol;  // solution from matlab
    mu_sol << 0.882465341807707, -0.357481399735795, 0.305715503943036,
        0.060963548709047, 0.017604684668861, 0.405131802621440,
        0.907877021028632, -0.107831058572566, 0.078202205612663,
        0.021805638274304, -0.239004483248557, 0.219012245162490,
        0.945997089559992, -5.496931139035293, -1.566265571930638, 0, 0, 0,
        1.000000000000000, 0, 0, 0, 0, 0, 1.000000000000000;

    BOOST_CHECK(max_diff(mu, mu_sol) < 1e-3);
}
